#!/usr/bin/env bash
#MISE description="Generate commit message from staged changes and commit"
#MISE dir="{{cwd}}"
#USAGE flag "--codex" help="Use Codex CLI instead of Claude Code"

set -euo pipefail

DOTFILES="${DOTFILES_PATH:-$(cd "$(dirname "$0")/../../.." && pwd)}"
USE_CODEX="${usage_codex:-false}"
ABORT_LABEL="--- コミットを中止 ---"

if ! command -v jq &>/dev/null; then
    echo "Error: jq command not found. Run 'mise install' to install dependencies." >&2
    exit 1
fi

if [[ "$USE_CODEX" == "true" ]]; then
    if ! command -v codex &>/dev/null; then
        echo "Error: codex command not found" >&2
        exit 1
    fi
    SKILL_PATH="${DOTFILES}/.codex/skills/auto-commit/SKILL.md"
else
    if ! command -v claude &>/dev/null; then
        echo "Error: claude command not found" >&2
        exit 1
    fi
    SKILL_PATH="${DOTFILES}/.claude/skills/auto-commit/SKILL.md"
fi

if [[ ! -f "$SKILL_PATH" ]]; then
    echo "Error: SKILL.md not found at $SKILL_PATH" >&2
    exit 1
fi

# --- Collect git data ---

COLLECT_SCRIPT="${DOTFILES}/.claude/skills/auto-commit/collect.sh"
if [[ ! -f "$COLLECT_SCRIPT" ]]; then
    echo "Error: collect.sh not found at $COLLECT_SCRIPT" >&2
    exit 1
fi

GIT_DATA=$(bash "$COLLECT_SCRIPT")

# --- Generate candidates via LLM ---

PROMPT="以下の git データを分析してコミットメッセージ候補を生成してください。JSON のみを出力すること。

<git-data>
${GIT_DATA}
</git-data>"

if [[ "$USE_CODEX" == "true" ]]; then
    OUTFILE=$(mktemp)
    ERRFILE=$(mktemp)
    trap 'rm -f "$OUTFILE" "$ERRFILE"' EXIT
    CODEX_OK=false
    for attempt in 1 2; do
        > "$OUTFILE"
        if printf '%s\n\n%s' "$(cat "$SKILL_PATH")" "$PROMPT" | timeout -k 5 15 codex exec \
            --sandbox read-only \
            -m gpt-5.1-codex-mini \
            -o "$OUTFILE" \
            - >/dev/null 2>"$ERRFILE"; then
            CODEX_OK=true
            break
        fi
        [[ $attempt -lt 2 ]] && echo "codex exec failed (attempt $attempt/2), retrying..." >&2
    done
    if [[ "$CODEX_OK" != "true" ]]; then
        echo "Error: codex exec failed after retries" >&2
        cat "$ERRFILE" >&2
        exit 1
    fi
    RESULT=$(cat "$OUTFILE")
else
    RESULT=$(printf '%s' "$PROMPT" | claude -p \
        --model haiku \
        --append-system-prompt "$(cat "$SKILL_PATH")")
fi

if [[ -z "$RESULT" ]]; then
    echo "Error: Failed to generate candidates" >&2
    exit 1
fi

# Extract JSON from LLM output (strip markdown fences, then parse with jq)
STRIPPED=$(echo "$RESULT" | sed '/^```/d')
if ! JSON=$(echo "$STRIPPED" | jq -e '.' 2>/dev/null); then
    echo "Error: Failed to parse JSON from LLM output" >&2
    echo "$RESULT" | head -20 >&2
    exit 1
fi

COUNT=$(echo "$JSON" | jq '.candidates | length')

if [[ "$COUNT" -eq 0 ]]; then
    echo "候補が生成されませんでした。" >&2
    exit 1
fi

# --- Build selection menu ---

# Build parallel arrays: MESSAGES for raw values, LINES for display
# Use @base64 to safely handle newlines/special chars in JSON fields
MESSAGES=()
LINES=()
while IFS= read -r encoded; do
    msg=$(echo "$encoded" | base64 -d | jq -r '.message')
    desc=$(echo "$encoded" | base64 -d | jq -r '.description')
    MESSAGES+=("$msg")
    LINES+=("$msg - $desc")
done < <(echo "$JSON" | jq -r '.candidates[] | @base64')

# Append abort option (LINES only)
LINES+=("$ABORT_LABEL")

echo ""

if [[ ! -t 0 || ! -t 1 ]]; then
    echo "Error: Interactive terminal required for commit message selection." >&2
    echo "Candidates:" >&2
    for line in "${LINES[@]}"; do
        [[ "$line" == "$ABORT_LABEL" ]] && continue
        echo "  $line" >&2
    done
    exit 1
fi

COMMIT_MSG=""
if command -v fzf &>/dev/null; then
    SELECTED=$(printf '%s\n' "${LINES[@]}" | fzf --prompt="コミットメッセージを選択> " --height=~10 --reverse) || exit 0
    if [[ -z "$SELECTED" || "$SELECTED" == "$ABORT_LABEL" ]]; then
        echo "Aborted."
        exit 0
    fi
    # Look up original message by matching display line
    for i in "${!LINES[@]}"; do
        if [[ "${LINES[$i]}" == "$SELECTED" ]]; then
            COMMIT_MSG="${MESSAGES[$i]}"
            break
        fi
    done
else
    echo "コミットメッセージを選択してください。"
    echo ""
    SELECTED=""
    select SELECTED in "${LINES[@]}"; do
        if [[ -n "$SELECTED" ]]; then
            break
        fi
        echo "無効な選択です。もう一度選んでください。" >&2
    done
    if [[ -z "$SELECTED" || "$SELECTED" == "$ABORT_LABEL" ]]; then
        echo "Aborted."
        exit 0
    fi
    # REPLY is 1-based index from select
    COMMIT_MSG="${MESSAGES[$((REPLY - 1))]}"
fi

if [[ -z "$COMMIT_MSG" ]]; then
    echo "Aborted."
    exit 0
fi

# --- Execute commit ---

echo ""
echo "Commit message: $COMMIT_MSG"
echo ""

# Record originally staged files for potential retry
# NUL bytes are lost in command substitution, so use array via read -d ''
STAGED_FILES=()
while IFS= read -r -d '' file; do
    STAGED_FILES+=("$file")
done < <(git diff --cached --name-only -z)
if git commit -m "$COMMIT_MSG"; then
    :
else
    echo ""
    # Retry once: pre-commit hooks may have auto-fixed files
    echo "Commit failed. Retrying with updated files..."
    git add -- "${STAGED_FILES[@]}"
    git commit -m "$COMMIT_MSG"
fi

echo ""
echo "--- Result ---"
echo "Hash:    $(git rev-parse --short HEAD)"
echo "Message: $(git log -1 --format='%s')"
echo "Files:   $(git diff-tree --no-commit-id --name-only -r HEAD | wc -l | tr -d ' ') file(s) changed"
